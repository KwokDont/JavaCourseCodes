## Week2 Homework

### 根据上述自己对于 1 和 2 的演示，写一段对于不同 GC 和堆内存的总结，提交到 GitHub。



#### 1.串行GC（Serial GC）

**开启方式：**

启动参数使用 -XX:+UseSerialGC

**GC算法：**

年轻代使用mark-copy(标记-复制)算法，老年代使用mark-sweep-compact(标记-清除-整理)算法

**特点：**

对年轻代和老年代的垃圾回收都会导致STW，不能充分利用多核cpu的计算资源，不管有多少个cpu，JVM在垃圾回收时只能使用单个核心。这样的话cpu占用率高，暂停时间长。

**改进：**

官方针对年轻代的垃圾回收做了改进，使用ParNew GC，可以对年轻代进行并行的垃圾回收，且可以配合CMS GC使用。

**适用场景：**

只适合几百MB堆内存的JVM，且是单核CPU的情况。



#### 2.并行GC

**开启方式：** 

Java6、7、8默认的GC算法，或添加启动参数 -XX:+UseParallelGC -XX:+UseParallelOldGC

**GC算法：**

年轻代使用mark-copy(标记-复制)算法，老年代使用mark-sweep-compact(标记-清除-整理)算法

**特点：**

对年轻代和老年代的垃圾回收扔会导致STW，但可以同时使用多个cpu内核进行垃圾回收。系统资源的利用率更高。默认使用系统核心数的线程来进行垃圾回收。设计目标是为了最大化吞吐量。且一般来说，它的吞吐量是最优的。

**适用场景：**

适用于多核服务器且更重视吞吐量的场景，因为对系统资源有效的利用，所以能实现更高的吞吐量。

**对比：**

相较于串行GC，并行GC的优势是在多核环境下会使用更多的核心线程进行垃圾回收，回收的效率更高，相应的GC暂停时间也会更短。



#### 3.CMS GC

**开启方式：**

启动参数使用 -XX:+UseConcMarkSweepGC

**GC 算法：**

年轻代使用并行STW的mark-copy(标记-复制)算法——ParNew，老年代使用并发mark-sweep(标记-清除)算法

**特点：**

- 该收集器的设计目标是为了降低GC暂停导致的系统延迟。
- 在老年代通过free-list管理空闲空间，而不直接整理old区内存，减少old区GC的暂停时间。
- 另外在mark-sweep阶段，GC线程和应用线程并发执行，这样的话GC线程就可以尽量少地干扰业务线程执行的连续性。
- 默认使用系统CPU核心数四分之一的线程进行GC。
- 在Old区GC的过程中可能会伴随多次Minor GC
- 初始标记和最终标记两个阶段还是会发生STW，其余时间GC和业务线程可以同时执行

**适用场景：**

多核心服务器，且业务系统对单次GC的暂停时间和延迟有比较高的要求，需要尽量短的GC暂停。

**对比：**

- 并行GC和CMS GC都是使用多线程来进行GC。
- 并行GC会使用所有的线程来进行GC，业务线程会被暂停。CMS GC中业务线程和GC线程是可以并发执行的，即大部分时间可以同时进行

**注意事项：**

1. 对象晋升失败(promotion failed)，老年代有足够的空间可以容纳晋升的对象，但是由于Old区GC算法没有整理的过程，空闲空间的碎片化，导致晋升失败，此时会触发单线程且伴随compact过程的Full GC。
2. 并发模式失败，新生代发生垃圾回收，同时老年代又没有足够的空间容纳晋升的对象时，CMS 垃圾回收就会退化成单线程的Full GC。所有的应用线程都会被暂停，老年代中所有的无效对象都被回收。

**解决方案：**

1. 针对第一点，一个是增大堆区年轻代空间(蓄水池效应更明显)从而降低晋升速率。或者在启动参数配置UseCMSCompactAtFullCollection以及CMSFullGCsBeforeCompaction。
2. 针对第二点，可以增加对内存，或者GC线程数。



#### 4.G1 GC

**开启方式：**

启动参数使用 -XX:+UseG1GC

**GC 算法：**

收集算法基于cms基础上改进。G1 GC采用启发式的算法，每次都会回收当前标记为年轻代的Region，已经部分标记为老年代的Region。在并发阶段会估算每个Region内部的垃圾数量，优先回收垃圾较多的Region。每次做增量式的垃圾回收，GC效率高，灵活控制暂停时间。

**特点：**

- 在初始标记、最终标记、清理阶段会发生STW。
- 目标是将STW的停顿时间和分布，变得可预期且可配置的，每次做增量式的GC。
- 堆不再区分年轻代和老生代，而是划分成多个Region(通常是2048个)，每个Region都可能被划分为Eden、Survivor、Old。
- 每次GC只回收部分区域，GC效率高

**适用场景：**

较大堆内存的JVM，蓄水池作用更明显，则可以考虑使用G1 GC，一般情况下可能一次Full GC都不会发生。

**对比：**

- 对比串行并行CMS GC，打破了以往分带的模式。
- 采用Region划分之后，G1 GC不需要每次都整理整个堆空间。
- 采用RSet和Satb算法，垃圾对象标记效率较cms有极大的提升。
- G1在初始标记阶段伴随一次Young GC，在最终标记阶段新增的无效引用会少很多，最终标记耗时少。

**注意事项：**

G1 GC在触发Full GC是，会退化成串行GC，即使用单线程回收垃圾，GC暂停时间可能到达秒级

1. G1在启动标记周期时，由于Old区被填满，G1会放弃标记周期，这是并发标记失败。
2. 晋升失败，当没有足够的内存供存活对象和晋升对象使用，由此触发Full GC。
3. 巨型对象分配失败，当巨型对象找不到合适的空间进行分配，就会触发Full GC

**解决方案：**

1. 针对上述第一点，可以增大堆内存数，增加Old区填满的时间。或者可以增加垃圾回收的线程数(-XX:ConcGCThreads)。问题可以归结为垃圾产生的速度太快了，要不减慢Old区填满，要不加快垃圾回收。
2. 针对第二点，可以通过设置-XX:G1ReservePrecent增加预留内存的百分比。或者可以通过降低IHOP提前进入标记周期。
   还有就是增加并发标记线程数。根本原因还是垃圾产生比回收快。
3. 针对第三点，可以增加堆内存，或者调整Region大小(-XX:G1HeapRegionSize)。

***增加堆内存向来是有效可行的办法***

***吞吐量最优并不意味着GC暂停的时间是最短的。***



#### 其他指标

**分配速率**

指单位时间内年轻代新增对象大小

**晋升速率**

指单位时间内堆区从年轻代晋升到年老代的对象大小